"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;
var _querystring = _interopRequireDefault(require("querystring"));

var _axiosError = _interopRequireDefault(require("axios-error"));
var _axios = _interopRequireDefault(require("axios"));
var _invariant = _interopRequireDefault(require("invariant"));function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function ownKeys(object, enumerableOnly) {var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {return Object.getOwnPropertyDescriptor(object, sym).enumerable;});keys.push.apply(keys, symbols);}return keys;}function _objectSpread(target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {ownKeys(source, true).forEach(function (key) {_defineProperty(target, key, source[key]);});} else if (Object.getOwnPropertyDescriptors) {Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));} else {ownKeys(source).forEach(function (key) {Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));});}}return target;}function _objectWithoutProperties(source, excluded) {if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];}}return target;}function _objectWithoutPropertiesLoose(source, excluded) {if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];}return target;}function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}


















function handleError(err) {
  if (err.response && err.response.data) {
    const { returnCode, returnMessage } = err.response.data;
    const msg = `LINE PAY API - ${returnCode} ${returnMessage}`;
    throw new _axiosError.default(msg, err);
  }
  throw new _axiosError.default(err.message, err);
}

function throwWhenNotSuccess(res) {
  if (res.data.returnCode !== '0000') {
    const { returnCode, returnMessage } = res.data;
    const msg = `LINE PAY API - ${returnCode} ${returnMessage}`;
    throw new _axiosError.default(msg);
  }
  return res.data.info;
}

class LinePay {
  static connect(config) {
    return new LinePay(config);
  }



  constructor({
    channelId,
    channelSecret,
    sandbox = false,
    origin })
  {_defineProperty(this, "_axios", void 0);
    const linePayOrigin = sandbox ?
    'https://sandbox-api-pay.line.me' :
    'https://api-pay.line.me';

    this._axios = _axios.default.create({
      baseURL: `${origin || linePayOrigin}/v2/`,
      headers: {
        'Content-Type': 'application/json',
        'X-LINE-ChannelId': channelId,
        'X-LINE-ChannelSecret': channelSecret } });


  }

  get axios() {
    return this._axios;
  }

  getPayments({
    transactionId,
    orderId } =



  {}) {
    (0, _invariant.default)(
    transactionId || orderId,
    'getPayments: One of `transactionId` or `orderId` must be provided');


    const query = {};

    if (transactionId) {
      query.transactionId = transactionId;
    }

    if (orderId) {
      query.orderId = orderId;
    }

    return this._axios.
    get(`/payments?${_querystring.default.stringify(query)}`).
    then(throwWhenNotSuccess, handleError);
  }

  getAuthorizations({
    transactionId,
    orderId } =



  {}) {
    (0, _invariant.default)(
    transactionId || orderId,
    'getAuthorizations: One of `transactionId` or `orderId` must be provided');


    const query = {};

    if (transactionId) {
      query.transactionId = transactionId;
    }

    if (orderId) {
      query.orderId = orderId;
    }

    return this._axios.
    get(`/payments/authorizations?${_querystring.default.stringify(query)}`).
    then(throwWhenNotSuccess, handleError);
  }

  reserve(_ref)
























  {let { productName, amount, currency, confirmUrl, orderId } = _ref,options = _objectWithoutProperties(_ref, ["productName", "amount", "currency", "confirmUrl", "orderId"]);
    return this._axios.
    post('/payments/request', _objectSpread({
      productName,
      amount,
      currency,
      confirmUrl,
      orderId },
    options)).

    then(throwWhenNotSuccess, handleError);
  }

  confirm(
  transactionId,
  {
    amount,
    currency })




  {
    return this._axios.
    post(`/payments/${transactionId}/confirm`, {
      amount,
      currency }).

    then(throwWhenNotSuccess, handleError);
  }

  capture(
  transactionId,
  {
    amount,
    currency })




  {
    return this._axios.
    post(`/payments/authorizations/${transactionId}/capture`, {
      amount,
      currency }).

    then(throwWhenNotSuccess, handleError);
  }

  void(transactionId) {
    return this._axios.
    post(`/payments/authorizations/${transactionId}/void`).
    then(throwWhenNotSuccess, handleError);
  }

  refund(transactionId, options = {}) {
    return this._axios.
    post(`/payments/${transactionId}/refund`, options).
    then(throwWhenNotSuccess, handleError);
  }}exports.default = LinePay;