'use strict';Object.defineProperty(exports, "__esModule", { value: true });var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};

var _querystring = require('querystring');var _querystring2 = _interopRequireDefault(_querystring);

var _axiosError = require('axios-error');var _axiosError2 = _interopRequireDefault(_axiosError);
var _axios = require('axios');var _axios2 = _interopRequireDefault(_axios);
var _debug = require('debug');var _debug2 = _interopRequireDefault(_debug);
var _lodash = require('lodash.omit');var _lodash2 = _interopRequireDefault(_lodash);
var _urlJoin = require('url-join');var _urlJoin2 = _interopRequireDefault(_urlJoin);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}function _asyncToGenerator(fn) {return function () {var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {return Promise.resolve(value).then(function (value) {step("next", value);}, function (err) {step("throw", err);});}}return step("next");});};}



































































const debugRequest = (0, _debug2.default)('messaging-api-slack');

function onRequest({ method, url, body }) {
  debugRequest(`${method} ${url}`);
  debugRequest('Outgoing request body:');
  debugRequest(JSON.stringify(body, null, 2));
}

class SlackOAuthClient {
  static connect(accessTokenOrConfig) {
    return new SlackOAuthClient(accessTokenOrConfig);
  }







  constructor(accessTokenOrConfig) {
    let origin;
    if (accessTokenOrConfig && typeof accessTokenOrConfig === 'object') {
      const config = accessTokenOrConfig;

      this._token = config.accessToken;
      this._onRequest = config.onRequest || onRequest;
      origin = config.origin;
    } else {
      // Bot User OAuth Access Token
      this._token = accessTokenOrConfig;
      this._onRequest = onRequest;
    }

    // Web API
    // https://api.slack.com/web
    this._axios = _axios2.default.create({
      baseURL: `${origin || 'https://slack.com'}/api/`,
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded' } });



    this._axios.interceptors.request.use(config => {
      this._onRequest({
        method: config.method,
        url: (0, _urlJoin2.default)(config.baseURL, config.url),
        headers: _extends({},
        config.headers.common,
        config.headers[config.method],
        (0, _lodash2.default)(config.headers, [
        'common',
        'get',
        'post',
        'put',
        'patch',
        'delete',
        'head'])),


        body: config.data });

      return config;
    });
  }

  get axios() {
    return this._axios;
  }

  get accessToken() {
    return this._token;
  }

  callMethod(
  method,
  _body = {})
  {var _this = this;return _asyncToGenerator(function* () {
      try {
        const body = (0, _lodash2.default)(_body, ['token', 'accessToken']);
        body.token = _body.accessToken || _body.token || _this._token;

        const response = yield _this._axios.post(
        method,
        _querystring2.default.stringify(body));const

        data = response.data,config = response.config,request = response.request;

        if (!data.ok) {
          throw new _axiosError2.default(`Slack API - ${data.error}`, {
            config,
            request,
            response });

        }

        return data;
      } catch (err) {
        throw new _axiosError2.default(err.message, err);
      }})();
  }

  /**
     * Gets information about a public channel.
     *
     * https://api.slack.com/methods/channels.info
     */
  getChannelInfo(
  channelId,
  options = {})
  {
    return this.callMethod('channels.info', _extends({
      channel: channelId },
    options)).
    then(data => data.channel);
  }

  /**
     * Lists all public channels in a Slack team.
     *
     * https://api.slack.com/methods/channels.list
     * FIXME: [breaking] support cursor, exclude_archived, exclude_members, limit
     */
  getChannelList(options = {}) {
    return this.callMethod('channels.list', options).then(
    data => data.channels);

  }

  /**
     * Retrieve information about a conversation.
     *
     * https://api.slack.com/methods/conversations.info
     */
  getConversationInfo(
  channelId,
  options = {})
  {
    return this.callMethod('conversations.info', _extends({
      channel: channelId },
    options)).
    then(data => data.channel);
  }

  /**
     * Retrieve members of a conversation.
     *
     * https://api.slack.com/methods/conversations.members
     */
  getConversationMembers(
  channelId,
  options = {})



  {
    return this.callMethod('conversations.members', _extends({
      channel: channelId },
    options)).
    then(data => ({
      members: data.members,
      next: data.response_metadata && data.response_metadata.next_cursor }));

  }

  getAllConversationMembers(
  channelId,
  options = {})
  {var _this2 = this;return _asyncToGenerator(function* () {
      let allMembers = [];
      let continuationCursor;

      do {var _ref =




        yield _this2.getConversationMembers(channelId, _extends({
          cursor: continuationCursor },
        options));const members = _ref.members,next = _ref.next;

        allMembers = allMembers.concat(members);
        continuationCursor = next;
      } while (continuationCursor);

      return allMembers;})();
  }

  /**
     * Lists all channels in a Slack team.
     *
     * https://api.slack.com/methods/conversations.list
     */
  getConversationList(
  options = {})



  {
    return this.callMethod('conversations.list', options).then(data => ({
      channels: data.channels,
      next: data.response_metadata && data.response_metadata.next_cursor }));

  }

  getAllConversationList(
  options = {})
  {var _this3 = this;return _asyncToGenerator(function* () {
      let allChannels = [];
      let continuationCursor;

      do {
        const _options = continuationCursor ? _extends({
          cursor: continuationCursor }, options) :
        options;var _ref2 =




        yield _this3.getConversationList(_options);const channels = _ref2.channels,next = _ref2.next;
        allChannels = allChannels.concat(channels);
        continuationCursor = next;
      } while (continuationCursor);

      return allChannels;})();
  }

  /**
     * Sends a message to a channel.
     *
     * https://api.slack.com/methods/chat.postMessage
     */
  postMessage(
  channel,
  message,


  options = {})
  {
    if (options.attachments && typeof options.attachments !== 'string') {
      // A JSON-based array of structured attachments, presented as a URL-encoded string.
      // eslint-disable-next-line no-param-reassign
      options.attachments = JSON.stringify(options.attachments);
    } else if (
    typeof message === 'object' &&
    message.attachments &&
    typeof message.attachments !== 'string')
    {
      // eslint-disable-next-line no-param-reassign
      message.attachments = JSON.stringify(message.attachments);
    }

    if (typeof message === 'string') {
      return this.callMethod('chat.postMessage', _extends({
        channel,
        text: message },
      options));

    }
    return this.callMethod('chat.postMessage', _extends({
      channel },
    message,
    options));

  }

  /**
     * Sends an ephemeral message to a user in a channel.
     *
     * https://api.slack.com/methods/chat.postMessage
     */
  postEphemeral(
  channel,
  user,
  message,


  options = {})
  {
    if (options.attachments && typeof options.attachments !== 'string') {
      // A JSON-based array of structured attachments, presented as a URL-encoded string.
      // eslint-disable-next-line no-param-reassign
      options.attachments = JSON.stringify(options.attachments);
    } else if (
    typeof message === 'object' &&
    message.attachments &&
    typeof message.attachments !== 'string')
    {
      // eslint-disable-next-line no-param-reassign
      message.attachments = JSON.stringify(message.attachments);
    }

    if (typeof message === 'string') {
      return this.callMethod('chat.postEphemeral', _extends({
        channel,
        user,
        text: message },
      options));

    }
    return this.callMethod('chat.postEphemeral', _extends({
      channel,
      user },
    message,
    options));

  }

  /**
     * Gets information about a user.
     *
     * https://api.slack.com/methods/users.info
     */
  getUserInfo(
  userId,
  options = {})
  {
    return this.callMethod('users.info', _extends({ user: userId }, options)).then(
    data => data.user);

  }

  /**
     * Lists all users in a Slack team.
     *
     * https://api.slack.com/methods/users.list
     * FIXME: [breaking] support include_locale, limit, presence
     */
  getUserList(
  cursorOrOptions)
  {
    if (typeof cursorOrOptions === 'string') {
      // cursorOrOptions is cursor string
      return this.callMethod('users.list', { cursor: cursorOrOptions }).then(
      data => ({
        members: data.members,
        next: data.response_metadata && data.response_metadata.next_cursor }));


    }

    // cursorOrOptions is options object
    return this.callMethod('users.list', cursorOrOptions).then(data => ({
      members: data.members,
      next: data.response_metadata && data.response_metadata.next_cursor }));

  }

  getAllUserList(options = {}) {var _this4 = this;return _asyncToGenerator(function* () {
      let allUsers = [];
      let continuationCursor;

      do {var _ref3 =




        yield _this4.getUserList(_extends({ cursor: continuationCursor }, options));const users = _ref3.members,next = _ref3.next;
        allUsers = allUsers.concat(users);
        continuationCursor = next;
      } while (continuationCursor);

      return allUsers;})();
  }}exports.default = SlackOAuthClient;