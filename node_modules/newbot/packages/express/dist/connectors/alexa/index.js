"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var connector_1 = require("../connector");
var newbot_sessions_1 = require("newbot-sessions");
var Alexa = __importStar(require("ask-sdk-core"));
var ask_sdk_express_adapter_1 = require("ask-sdk-express-adapter");
var lodash_1 = __importDefault(require("lodash"));
var AlexaConnector = /** @class */ (function (_super) {
    __extends(AlexaConnector, _super);
    function AlexaConnector(app, converse, settings) {
        return _super.call(this, app, converse, settings) || this;
    }
    AlexaConnector.prototype.handler = function () {
        var _this = this;
        var exec = function (handlerInput, eventName, eventData) {
            if (eventData === void 0) { eventData = {}; }
            var session = new newbot_sessions_1.AlexaSession(handlerInput);
            var text = lodash_1.default.get(handlerInput.requestEnvelope, 'request.intent.slots.any.value');
            var p;
            if (eventName) {
                p = _this.event({
                    name: eventName,
                    data: eventData
                }, session);
            }
            else {
                p = _this.exec(text, session);
            }
            return p.then(function () { return session.response; });
        };
        var LaunchRequestHandler = {
            canHandle: function (handlerInput) {
                return Alexa.getRequestType(handlerInput.requestEnvelope) === 'LaunchRequest';
            },
            handle: function (handlerInput) {
                return exec(handlerInput, 'start');
            }
        };
        var NewBotHandler = {
            canHandle: function (handlerInput) {
                return handlerInput.requestEnvelope.request.type === 'IntentRequest'
                    && handlerInput.requestEnvelope.request.intent.name === 'NewBotIntent';
            },
            handle: function (handlerInput) {
                return exec(handlerInput);
            }
        };
        var NewBotEventHandler = {
            canHandle: function (handlerInput) {
                var _a = handlerInput.requestEnvelope.request, type = _a.type, reason = _a.reason;
                var intentName = lodash_1.default.get(handlerInput.requestEnvelope, 'request.intent.name');
                if ((type == 'IntentRequest' || type == 'SessionEndedRequest') && intentName && /^AMAZON/.test(intentName)) {
                    handlerInput.eventName = intentName;
                    return true;
                }
                else if (type == 'Connections.Response') {
                    var _b = handlerInput.requestEnvelope.request, name_1 = _b.name, payload = _b.payload;
                    handlerInput.eventName = "AMAZON." + name_1;
                    handlerInput.eventData = payload;
                    return true;
                }
                else if (type == 'SessionEndedRequest' && reason == 'ERROR') {
                    var error = handlerInput.requestEnvelope.request.error;
                    handlerInput.eventName = 'AMAZON.Error';
                    handlerInput.eventData = error;
                    if (error.type == 'INVALID_RESPONSE') {
                        console.log("Warning! No answer is sent.");
                    }
                    return true;
                }
                return false;
            },
            handle: function (handlerInput) {
                return exec(handlerInput, handlerInput.eventName, handlerInput.eventData);
            }
        };
        var ErrorHandler = {
            canHandle: function () {
                return true;
            },
            handle: function (handlerInput, error) {
                console.log("~~~~ Error handled: " + error.stack);
                var speakOutput = "Sorry, I had trouble doing what you asked. Please try again.";
                return handlerInput.responseBuilder
                    .speak(speakOutput)
                    .reprompt(speakOutput)
                    .getResponse();
            }
        };
        var skillBuilder = Alexa.SkillBuilders.custom()
            .addRequestHandlers(LaunchRequestHandler, NewBotHandler, NewBotEventHandler)
            .addErrorHandlers(ErrorHandler)
            .withApiClient(new Alexa.DefaultApiClient());
        var skill = skillBuilder.create();
        var adapter = new ask_sdk_express_adapter_1.ExpressAdapter(skill, true, true);
        return adapter;
    };
    AlexaConnector.prototype.registerRoutes = function () {
        var adapter = this.handler();
        this.app.post(this.settings.path || '/alexa', adapter.getRequestHandlers());
    };
    AlexaConnector.prototype.proactive = function (obj) {
        // TODO
    };
    return AlexaConnector;
}(connector_1.Connector));
exports.AlexaConnector = AlexaConnector;
