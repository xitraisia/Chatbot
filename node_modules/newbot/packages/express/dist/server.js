"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var connectors_1 = __importDefault(require("./connectors"));
var lodash_1 = __importDefault(require("lodash"));
var body_parser_1 = __importDefault(require("body-parser"));
var fs_1 = __importDefault(require("fs"));
var newbot_1 = require("newbot");
var NewBotExpressServer = /** @class */ (function () {
    function NewBotExpressServer(app, settings, converse) {
        if (settings === void 0) { settings = {}; }
        this.app = app;
        this.settings = settings;
        this.converse = converse;
        this.config = {};
        this.platforms = {};
        var mainSkill;
        if (!this.converse) {
            var botPath = settings.botPath + '/dist/node/bot.js';
            if (!fs_1.default.existsSync(botPath)) {
                console.log('Bot skill not exists. use "newbot build" before');
                process.exit();
            }
            mainSkill = require(botPath);
            var converseOptions = {};
            if (settings.modelPath) {
                converseOptions.model = settings.modelPath;
            }
            this.converse = new newbot_1.NewBot(mainSkill, converseOptions);
        }
        if (settings.botConfigFile && !lodash_1.default.isString(settings.botConfigFile)) {
            this.config = settings.botConfigFile;
        }
        else {
            var configFilePath = settings.botPath + '/' + (settings.botConfigFile || 'newbot.config.js');
            if (fs_1.default.existsSync(configFilePath)) {
                this.config = require(configFilePath);
            }
        }
        if (settings.io) {
            this.app.set('_io', settings.io);
        }
    }
    NewBotExpressServer.prototype.registerRoutes = function () {
        var _this = this;
        var server;
        var registerRoute = function (connectorName) {
            var connector = connectors_1.default[connectorName];
            var settings = _this.getSettings(connectorName);
            if (settings) {
                _this.platforms[connectorName] = new connector(_this.app, _this.converse, settings);
                _this.app.post(_this.platforms[connectorName].routePath() + connectorName + '/proactive', function (req, res, next) {
                    try {
                        if (_this.settings.proactiveAuth) {
                            var token = req.headers['authorization'];
                            if (token != _this.settings.proactiveAuth) {
                                var error = new Error('Proactive endpoints must have authorization');
                                error.status = 403;
                                throw error;
                            }
                        }
                        _this.platforms[connectorName].proactive(__assign(__assign({}, req.body), { agent: 'agent' }));
                        res.status(204).send();
                    }
                    catch (err) {
                        next(err);
                    }
                });
                return _this.platforms[connectorName].registerRoutes();
            }
        };
        registerRoute('alexa');
        this.app.use(body_parser_1.default.json({
            verify: function (req, res, buf) {
                req.rawBody = buf.toString();
            },
        }));
        for (var connectorName in connectors_1.default) {
            if (connectorName == 'alexa')
                continue;
            var ret = registerRoute(connectorName);
            if (connectorName == 'website') {
                server = ret;
            }
        }
        return {
            server: server
        };
    };
    NewBotExpressServer.prototype.proactive = function (obj) {
        return this.proactiveEvent(obj, false);
    };
    NewBotExpressServer.prototype.proactiveEvent = function (obj, isEvent) {
        if (isEvent === void 0) { isEvent = true; }
        if (!obj.event && isEvent) {
            throw 'You did not put the event property';
        }
        if (lodash_1.default.isString(obj.event)) {
            obj.event = {
                name: obj.event,
                data: {}
            };
        }
        if (!obj.platform)
            throw 'Please indicate the platform (messenger, telegram, viber, etc.)';
        if (!obj.userId)
            throw 'Please enter the user ID';
        if (isEvent && !obj.event.name)
            throw 'Please indicate the name of the event to be triggered';
        var client = this.platforms[obj.platform];
        if (!client)
            throw "This " + obj.platform + " platform does not exist";
        return client.proactive(obj);
    };
    NewBotExpressServer.prototype.getSettings = function (platformName) {
        var production = lodash_1.default.get(this.config, 'production.platforms.' + platformName);
        var dev = lodash_1.default.get(this.config, 'platforms.' + platformName);
        var obj = lodash_1.default.merge(process.env.NODE_ENV == 'production' ? production : dev, this.settings[platformName]);
        obj.output = this.settings.output || {};
        obj.baseUrl = this.settings.baseUrl || '';
        return obj;
    };
    return NewBotExpressServer;
}());
exports.NewBotExpressServer = NewBotExpressServer;
